"""
AI Exploit Recommender Module
Uses machine learning to recommend optimal exploits for discovered vulnerabilities
"""

import asyncio
import json
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import pickle
import os

# ML imports
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

from ..utils.logger import get_logger

class ExploitRecommender:
    """AI-powered exploit recommendation system"""
    
    def __init__(self, config):
        """Initialize the exploit recommender"""
        self.config = config
        self.logger = get_logger(__name__)
        self.models_path = config.models_path
        
        # ML models
        self.success_predictor = None
        self.exploit_classifier = None
        self.text_vectorizer = None
        self.feature_scaler = None
        
        # Exploit database
        self.exploit_database = {}
        self.vulnerability_exploit_map = {}
        self.exploit_features = {}
        
        # Recommendation cache
        self.recommendation_cache = {}
        
        self.is_initialized = False
    
    async def initialize(self) -> bool:
        """Initialize the exploit recommender"""
        try:
            self.logger.info("ðŸŽ¯ Initializing AI Exploit Recommender...")
            
            # Load exploit database
            await self._load_exploit_database()
            
            # Load or create models
            await self._load_or_create_models()
            
            # Build exploit features
            await self._build_exploit_features()
            
            self.is_initialized = True
            self.logger.info("âœ… Exploit Recommender initialized successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to initialize Exploit Recommender: {e}")
            return False
    
    async def recommend(self, target: str, vulnerabilities: List[Dict]) -> List[Dict]:
        """Recommend exploits for given vulnerabilities"""
        if not self.is_initialized:
            await self.initialize()
        
        try:
            self.logger.info(f"ðŸ§  Generating exploit recommendations for {len(vulnerabilities)} vulnerabilities")
            
            recommendations = []
            
            for vulnerability in vulnerabilities:
                vuln_recommendations = await self._recommend_for_vulnerability(target, vulnerability)
                recommendations.extend(vuln_recommendations)
            
            # Remove duplicates and rank recommendations
            unique_recommendations = await self._deduplicate_and_rank(recommendations, target)
            
            # Enhance with success probability
            enhanced_recommendations = await self._enhance_with_success_probability(
                unique_recommendations, target, vulnerabilities
            )
            
            # Sort by confidence and success probability
            enhanced_recommendations.sort(
                key=lambda x: (x.get('confidence', 0) * x.get('success_probability', 0)), 
                reverse=True
            )
            
            self.logger.info(f"ðŸŽ¯ Generated {len(enhanced_recommendations)} exploit recommendations")
            return enhanced_recommendations[:10]  # Return top 10
            
        except Exception as e:
            self.logger.error(f"âŒ Exploit recommendation failed: {e}")
            return []
    
    async def _recommend_for_vulnerability(self, target: str, vulnerability: Dict) -> List[Dict]:
        """Recommend exploits for a specific vulnerability"""
        recommendations = []
        
        try:
            vuln_type = vulnerability.get('type', '')
            service = vulnerability.get('service', '')
            port = vulnerability.get('port', 0)
            cve_id = vulnerability.get('cve_id', '')
            
            # Direct CVE mapping
            if cve_id:
                cve_exploits = await self._get_exploits_for_cve(cve_id)
                recommendations.extend(cve_exploits)
            
            # Service-based recommendations
            if service:
                service_exploits = await self._get_exploits_for_service(service, port)
                recommendations.extend(service_exploits)
            
            # Vulnerability type recommendations
            if vuln_type:
                type_exploits = await self._get_exploits_for_type(vuln_type)
                recommendations.extend(type_exploits)
            
            # AI-based similarity matching
            ai_exploits = await self._get_ai_recommendations(vulnerability)
            recommendations.extend(ai_exploits)
            
            # Add vulnerability context to recommendations
            for rec in recommendations:
                rec['vulnerability'] = vulnerability
                rec['target'] = target
            
        except Exception as e:
            self.logger.error(f"Vulnerability recommendation error: {e}")
        
        return recommendations
    
    async def _get_exploits_for_cve(self, cve_id: str) -> List[Dict]:
        """Get exploits mapped to specific CVE"""
        exploits = []
        
        if cve_id in self.vulnerability_exploit_map:
            exploit_names = self.vulnerability_exploit_map[cve_id]
            for exploit_name in exploit_names:
                if exploit_name in self.exploit_database:
                    exploit_info = self.exploit_database[exploit_name].copy()
                    exploit_info.update({
                        'recommendation_reason': f'Direct CVE mapping: {cve_id}',
                        'confidence': 0.9,
                        'exploit_name': exploit_name
                    })
                    exploits.append(exploit_info)
        
        return exploits
    
    async def _get_exploits_for_service(self, service: str, port: int) -> List[Dict]:
        """Get exploits for specific service"""
        exploits = []
        
        # Service-specific exploit mapping
        service_exploit_map = {
            'ssh': ['auxiliary/scanner/ssh/ssh_login', 'auxiliary/scanner/ssh/ssh_enumusers'],
            'ftp': ['auxiliary/scanner/ftp/ftp_login', 'exploit/unix/ftp/vsftpd_234_backdoor'],
            'http': ['auxiliary/scanner/http/dir_scanner', 'auxiliary/scanner/http/http_login'],
            'https': ['auxiliary/scanner/http/dir_scanner', 'auxiliary/scanner/http/ssl_version'],
            'telnet': ['auxiliary/scanner/telnet/telnet_login'],
            'smtp': ['auxiliary/scanner/smtp/smtp_enum', 'auxiliary/scanner/smtp/smtp_relay'],
            'mysql': ['auxiliary/scanner/mysql/mysql_login', 'auxiliary/scanner/mysql/mysql_version'],
            'mssql': ['auxiliary/scanner/mssql/mssql_login', 'exploit/windows/mssql/mssql_payload'],
            'postgresql': ['auxiliary/scanner/postgres/postgres_login'],
            'vnc': ['auxiliary/scanner/vnc/vnc_login'],
            'rdp': ['auxiliary/scanner/rdp/rdp_scanner']
        }
        
        if service.lower() in service_exploit_map:
            exploit_names = service_exploit_map[service.lower()]
            for exploit_name in exploit_names:
                exploit_info = {
                    'exploit_name': exploit_name,
                    'type': 'auxiliary' if 'auxiliary' in exploit_name else 'exploit',
                    'description': f'Exploit for {service} service',
                    'targets': [f'{service} service on port {port}'],
                    'rank': 'Normal',
                    'platform': ['Generic'],
                    'recommendation_reason': f'Service-based recommendation for {service}',
                    'confidence': 0.7
                }
                exploits.append(exploit_info)
        
        return exploits
    
    async def _get_exploits_for_type(self, vuln_type: str) -> List[Dict]:
        """Get exploits for vulnerability type"""
        exploits = []
        
        type_exploit_map = {
            'default_credentials': [
                'auxiliary/scanner/ssh/ssh_login',
                'auxiliary/scanner/ftp/ftp_login',
                'auxiliary/scanner/telnet/telnet_login'
            ],
            'unencrypted_protocol': [
                'auxiliary/scanner/snmp/snmp_enum',
                'auxiliary/sniffer/psnuffle'
            ],
            'buffer_overflow': [
                'exploit/windows/smb/ms17_010_eternalblue',
                'exploit/windows/smb/ms08_067_netapi'
            ],
            'sql_injection': [
                'auxiliary/scanner/mssql/mssql_login',
                'auxiliary/admin/mssql/mssql_enum'
            ],
            'web_vulnerability': [
                'auxiliary/scanner/http/dir_scanner',
                'auxiliary/scanner/http/files_dir'
            ]
        }
        
        if vuln_type in type_exploit_map:
            exploit_names = type_exploit_map[vuln_type]
            for exploit_name in exploit_names:
                exploit_info = {
                    'exploit_name': exploit_name,
                    'type': 'auxiliary' if 'auxiliary' in exploit_name else 'exploit',
                    'description': f'Exploit for {vuln_type}',
                    'rank': 'Normal',
                    'platform': ['Generic'],
                    'recommendation_reason': f'Vulnerability type recommendation for {vuln_type}',
                    'confidence': 0.6
                }
                exploits.append(exploit_info)
        
        return exploits
    
    async def _get_ai_recommendations(self, vulnerability: Dict) -> List[Dict]:
        """Get AI-based exploit recommendations using similarity matching"""
        recommendations = []
        
        try:
            if not self.text_vectorizer or not self.exploit_features:
                return recommendations
            
            # Create vulnerability description
            vuln_description = self._create_vulnerability_description(vulnerability)
            
            # Vectorize vulnerability description
            vuln_vector = self.text_vectorizer.transform([vuln_description])
            
            # Calculate similarity with exploit descriptions
            similarities = []
            exploit_names = list(self.exploit_features.keys())
            
            for exploit_name in exploit_names:
                if exploit_name in self.exploit_database:
                    exploit_desc = self.exploit_database[exploit_name].get('description', '')
                    exploit_vector = self.text_vectorizer.transform([exploit_desc])
                    similarity = cosine_similarity(vuln_vector, exploit_vector)[0][0]
                    similarities.append((exploit_name, similarity))
            
            # Sort by similarity and take top matches
            similarities.sort(key=lambda x: x[1], reverse=True)
            
            for exploit_name, similarity in similarities[:5]:
                if similarity > 0.3:  # Threshold for similarity
                    exploit_info = self.exploit_database[exploit_name].copy()
                    exploit_info.update({
                        'exploit_name': exploit_name,
                        'recommendation_reason': f'AI similarity matching (score: {similarity:.2f})',
                        'confidence': similarity,
                        'similarity_score': similarity
                    })
                    recommendations.append(exploit_info)
        
        except Exception as e:
            self.logger.error(f"AI recommendation error: {e}")
        
        return recommendations
    
    def _create_vulnerability_description(self, vulnerability: Dict) -> str:
        """Create a text description from vulnerability data"""
        parts = []
        
        if 'description' in vulnerability:
            parts.append(vulnerability['description'])
        
        if 'service' in vulnerability:
            parts.append(f"service {vulnerability['service']}")
        
        if 'type' in vulnerability:
            parts.append(f"type {vulnerability['type']}")
        
        if 'cve_id' in vulnerability:
            parts.append(f"CVE {vulnerability['cve_id']}")
        
        return ' '.join(parts)
    
    async def _deduplicate_and_rank(self, recommendations: List[Dict], target: str) -> List[Dict]:
        """Remove duplicates and rank recommendations"""
        seen_exploits = set()
        unique_recommendations = []
        
        for rec in recommendations:
            exploit_name = rec.get('exploit_name', '')
            if exploit_name not in seen_exploits:
                seen_exploits.add(exploit_name)
                unique_recommendations.append(rec)
        
        # Rank by confidence and exploit rank
        def rank_score(rec):
            confidence = rec.get('confidence', 0)
            exploit_rank = rec.get('rank', 'Normal')
            
            rank_scores = {
                'Excellent': 1.0,
                'Great': 0.9,
                'Good': 0.8,
                'Normal': 0.7,
                'Average': 0.6,
                'Low': 0.5,
                'Manual': 0.4
            }
            
            rank_modifier = rank_scores.get(exploit_rank, 0.5)
            return confidence * rank_modifier
        
        unique_recommendations.sort(key=rank_score, reverse=True)
        return unique_recommendations
    
    async def _enhance_with_success_probability(self, recommendations: List[Dict], 
                                              target: str, vulnerabilities: List[Dict]) -> List[Dict]:
        """Enhance recommendations with success probability"""
        enhanced = []
        
        for rec in recommendations:
            try:
                # Calculate success probability based on multiple factors
                success_prob = await self._calculate_success_probability(rec, target, vulnerabilities)
                rec['success_probability'] = success_prob
                
                # Add execution difficulty
                difficulty = await self._calculate_execution_difficulty(rec)
                rec['execution_difficulty'] = difficulty
                
                # Add required options analysis
                options_analysis = await self._analyze_required_options(rec)
                rec['options_analysis'] = options_analysis
                
                enhanced.append(rec)
                
            except Exception as e:
                self.logger.error(f"Enhancement error for {rec.get('exploit_name', 'unknown')}: {e}")
                enhanced.append(rec)
        
        return enhanced
    
    async def _calculate_success_probability(self, recommendation: Dict, 
                                           target: str, vulnerabilities: List[Dict]) -> float:
        """Calculate probability of exploit success"""
        try:
            base_probability = 0.5
            
            # Adjust based on exploit rank
            rank = recommendation.get('rank', 'Normal')
            rank_modifiers = {
                'Excellent': 0.9,
                'Great': 0.8,
                'Good': 0.7,
                'Normal': 0.6,
                'Average': 0.5,
                'Low': 0.4,
                'Manual': 0.3
            }
            probability = rank_modifiers.get(rank, 0.5)
            
            # Adjust based on recommendation confidence
            confidence = recommendation.get('confidence', 0.5)
            probability = (probability + confidence) / 2
            
            # Adjust based on vulnerability severity
            related_vuln = recommendation.get('vulnerability', {})
            severity_score = related_vuln.get('severity_score', 5.0)
            severity_modifier = min(severity_score / 10.0, 1.0)
            probability *= severity_modifier
            
            # Adjust based on exploit type
            exploit_type = recommendation.get('type', 'exploit')
            if exploit_type == 'auxiliary':
                probability *= 0.8  # Auxiliary modules are generally more reliable
            
            return min(probability, 1.0)
            
        except Exception as e:
            self.logger.error(f"Success probability calculation error: {e}")
            return 0.5
    
    async def _calculate_execution_difficulty(self, recommendation: Dict) -> str:
        """Calculate execution difficulty"""
        try:
            difficulty_score = 0
            
            # Check required options
            required_options = recommendation.get('required_options', [])
            difficulty_score += len(required_options) * 0.1
            
            # Check exploit type
            exploit_type = recommendation.get('type', 'exploit')
            if exploit_type == 'exploit':
                difficulty_score += 0.3
            
            # Check rank
            rank = recommendation.get('rank', 'Normal')
            if rank in ['Manual', 'Low']:
                difficulty_score += 0.4
            
            if difficulty_score < 0.3:
                return 'Easy'
            elif difficulty_score < 0.6:
                return 'Medium'
            else:
                return 'Hard'
                
        except Exception as e:
            self.logger.error(f"Difficulty calculation error: {e}")
            return 'Medium'
    
    async def _analyze_required_options(self, recommendation: Dict) -> Dict:
        """Analyze required options for exploit"""
        analysis = {
            'total_options': 0,
            'auto_configurable': 0,
            'manual_required': 0,
            'missing_options': []
        }
        
        try:
            required_options = recommendation.get('required_options', [])
            analysis['total_options'] = len(required_options)
            
            # Categorize options
            auto_configurable_options = ['RHOSTS', 'RHOST', 'RPORT', 'LHOST', 'LPORT']
            
            for option in required_options:
                if option in auto_configurable_options:
                    analysis['auto_configurable'] += 1
                else:
                    analysis['manual_required'] += 1
                    analysis['missing_options'].append(option)
            
        except Exception as e:
            self.logger.error(f"Options analysis error: {e}")
        
        return analysis
    
    async def _load_exploit_database(self):
        """Load exploit database"""
        # Simplified exploit database - in practice, this would be much more comprehensive
        self.exploit_database = {
            'exploit/windows/smb/ms17_010_eternalblue': {
                'description': 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
                'rank': 'Great',
                'platform': ['Windows'],
                'targets': ['Windows 7', 'Windows 2008', 'Windows 8.1', 'Windows 2012'],
                'required_options': ['RHOSTS', 'RPORT'],
                'type': 'exploit'
            },
            'exploit/windows/smb/ms08_067_netapi': {
                'description': 'MS08-067 Microsoft Server Service Relative Path Stack Corruption',
                'rank': 'Great',
                'platform': ['Windows'],
                'targets': ['Windows 2000', 'Windows XP', 'Windows 2003'],
                'required_options': ['RHOSTS', 'RPORT'],
                'type': 'exploit'
            },
            'auxiliary/scanner/ssh/ssh_login': {
                'description': 'SSH Login Check Scanner',
                'rank': 'Normal',
                'platform': ['Generic'],
                'targets': ['SSH servers'],
                'required_options': ['RHOSTS', 'USERNAME', 'PASSWORD'],
                'type': 'auxiliary'
            },
            'auxiliary/scanner/ftp/ftp_login': {
                'description': 'FTP Authentication Scanner',
                'rank': 'Normal',
                'platform': ['Generic'],
                'targets': ['FTP servers'],
                'required_options': ['RHOSTS', 'USERNAME', 'PASSWORD'],
                'type': 'auxiliary'
            },
            'exploit/unix/ftp/vsftpd_234_backdoor': {
                'description': 'VSFTPD v2.3.4 Backdoor Command Execution',
                'rank': 'Excellent',
                'platform': ['Linux', 'Unix'],
                'targets': ['VSFTPD 2.3.4'],
                'required_options': ['RHOSTS', 'RPORT'],
                'type': 'exploit'
            }
        }
        
        # CVE to exploit mapping
        self.vulnerability_exploit_map = {
            'CVE-2017-0144': ['exploit/windows/smb/ms17_010_eternalblue'],
            'CVE-2008-4250': ['exploit/windows/smb/ms08_067_netapi'],
            'CVE-2011-2523': ['exploit/unix/ftp/vsftpd_234_backdoor']
        }
    
    async def _load_or_create_models(self):
        """Load or create ML models"""
        try:
            # Text vectorizer for similarity matching
            self.text_vectorizer = TfidfVectorizer(
                max_features=1000,
                stop_words='english',
                lowercase=True
            )
            
            # Fit vectorizer on exploit descriptions
            descriptions = [exploit['description'] for exploit in self.exploit_database.values()]
            if descriptions:
                self.text_vectorizer.fit(descriptions)
            
            # Success predictor (simplified)
            self.success_predictor = RandomForestClassifier(n_estimators=50, random_state=42)
            
            # Train with dummy data (in practice, would use real exploit success data)
            X_dummy = np.random.rand(100, 5)  # Features: rank, confidence, severity, etc.
            y_dummy = np.random.rand(100)  # Success probability
            self.success_predictor.fit(X_dummy, y_dummy)
            
        except Exception as e:
            self.logger.error(f"Model loading error: {e}")
    
    async def _build_exploit_features(self):
        """Build feature vectors for exploits"""
        try:
            for exploit_name, exploit_info in self.exploit_database.items():
                features = {
                    'rank_score': self._rank_to_score(exploit_info.get('rank', 'Normal')),
                    'platform_count': len(exploit_info.get('platform', [])),
                    'target_count': len(exploit_info.get('targets', [])),
                    'required_options_count': len(exploit_info.get('required_options', [])),
                    'is_auxiliary': int(exploit_info.get('type') == 'auxiliary')
                }
                self.exploit_features[exploit_name] = features
                
        except Exception as e:
            self.logger.error(f"Feature building error: {e}")
    
    def _rank_to_score(self, rank: str) -> float:
        """Convert exploit rank to numerical score"""
        rank_scores = {
            'Excellent': 1.0,
            'Great': 0.9,
            'Good': 0.8,
            'Normal': 0.7,
            'Average': 0.6,
            'Low': 0.5,
            'Manual': 0.4
        }
        return rank_scores.get(rank, 0.5)
    
    def is_ready(self) -> bool:
        """Check if recommender is ready"""
        return (self.is_initialized and 
                self.text_vectorizer is not None and 
                bool(self.exploit_database))
