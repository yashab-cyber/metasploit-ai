"""
AI Vulnerability Analyzer Module
Uses machine learning to analyze and classify vulnerabilities
"""

import asyncio
import json
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import pickle
import os

# ML imports
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report

# Deep learning imports
try:
    import tensorflow as tf
    from tensorflow.keras.models import Sequential, load_model
    from tensorflow.keras.layers import Dense, LSTM, Embedding, Dropout
    from tensorflow.keras.preprocessing.text import Tokenizer
    from tensorflow.keras.preprocessing.sequence import pad_sequences
    TENSORFLOW_AVAILABLE = True
except ImportError:
    TENSORFLOW_AVAILABLE = False

from ..utils.logger import get_logger

class VulnerabilityAnalyzer:
    """AI-powered vulnerability analysis and classification"""
    
    def __init__(self, config):
        """Initialize the vulnerability analyzer"""
        self.config = config
        self.logger = get_logger(__name__)
        self.models_path = config.models_path
        
        # ML models
        self.severity_classifier = None
        self.exploitability_predictor = None
        self.vulnerability_classifier = None
        self.text_vectorizer = None
        self.feature_scaler = None
        
        # Deep learning models
        self.dl_model = None
        self.tokenizer = None
        
        # Model metadata
        self.model_version = "1.0.0"
        self.last_trained = None
        self.is_initialized = False
        
        # Vulnerability database
        self.vuln_database = {}
        self.cve_patterns = {}
        
    async def initialize(self) -> bool:
        """Initialize AI models and load pre-trained weights"""
        try:
            self.logger.info("ðŸ§  Initializing AI Vulnerability Analyzer...")
            
            # Create models directory
            os.makedirs(self.models_path, exist_ok=True)
            
            # Load or create models
            await self._load_or_create_models()
            
            # Load vulnerability database
            await self._load_vulnerability_database()
            
            # Load CVE patterns
            await self._load_cve_patterns()
            
            self.is_initialized = True
            self.logger.info("âœ… Vulnerability Analyzer initialized successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ Failed to initialize Vulnerability Analyzer: {e}")
            return False
    
    async def analyze(self, scan_data: Dict) -> List[Dict]:
        """Analyze scan data and identify vulnerabilities"""
        if not self.is_initialized:
            await self.initialize()
        
        try:
            vulnerabilities = []
            
            # Extract features from scan data
            features = await self._extract_features(scan_data)
            
            # Analyze services for vulnerabilities
            if 'services' in scan_data:
                for service in scan_data['services']:
                    service_vulns = await self._analyze_service(service, features)
                    vulnerabilities.extend(service_vulns)
            
            # Analyze OS for vulnerabilities
            if 'os_info' in scan_data:
                os_vulns = await self._analyze_os(scan_data['os_info'], features)
                vulnerabilities.extend(os_vulns)
            
            # Analyze open ports
            if 'ports' in scan_data:
                port_vulns = await self._analyze_ports(scan_data['ports'], features)
                vulnerabilities.extend(port_vulns)
            
            # Enhance vulnerabilities with AI predictions
            enhanced_vulns = await self._enhance_vulnerabilities(vulnerabilities, features)
            
            # Sort by severity and confidence
            enhanced_vulns.sort(key=lambda x: (x.get('severity_score', 0), x.get('confidence', 0)), reverse=True)
            
            self.logger.info(f"ðŸ” Identified {len(enhanced_vulns)} potential vulnerabilities")
            return enhanced_vulns
            
        except Exception as e:
            self.logger.error(f"âŒ Vulnerability analysis failed: {e}")
            return []
    
    async def _analyze_service(self, service: Dict, features: Dict) -> List[Dict]:
        """Analyze a specific service for vulnerabilities"""
        vulnerabilities = []
        
        try:
            service_name = service.get('name', '').lower()
            version = service.get('version', '')
            port = service.get('port', 0)
            
            # Check known vulnerabilities
            known_vulns = await self._check_known_vulnerabilities(service_name, version)
            vulnerabilities.extend(known_vulns)
            
            # AI-based vulnerability prediction
            ai_vulns = await self._predict_service_vulnerabilities(service, features)
            vulnerabilities.extend(ai_vulns)
            
            # Check for default credentials
            if await self._has_default_credentials(service):
                vulnerabilities.append({
                    'type': 'default_credentials',
                    'service': service_name,
                    'port': port,
                    'severity': 'High',
                    'severity_score': 8.0,
                    'description': f'Service {service_name} may have default credentials',
                    'recommendation': 'Change default credentials immediately',
                    'confidence': 0.7
                })
            
            # Check for unencrypted protocols
            if await self._is_unencrypted_protocol(service):
                vulnerabilities.append({
                    'type': 'unencrypted_protocol',
                    'service': service_name,
                    'port': port,
                    'severity': 'Medium',
                    'severity_score': 6.0,
                    'description': f'Service {service_name} uses unencrypted protocol',
                    'recommendation': 'Implement encryption (TLS/SSL)',
                    'confidence': 0.9
                })
            
        except Exception as e:
            self.logger.error(f"Service analysis error: {e}")
        
        return vulnerabilities
    
    async def _analyze_os(self, os_info: Dict, features: Dict) -> List[Dict]:
        """Analyze operating system for vulnerabilities"""
        vulnerabilities = []
        
        try:
            os_name = os_info.get('name', '').lower()
            os_version = os_info.get('version', '')
            
            # Check for known OS vulnerabilities
            os_vulns = await self._check_os_vulnerabilities(os_name, os_version)
            vulnerabilities.extend(os_vulns)
            
            # Check for outdated OS
            if await self._is_outdated_os(os_info):
                vulnerabilities.append({
                    'type': 'outdated_os',
                    'os': os_name,
                    'version': os_version,
                    'severity': 'High',
                    'severity_score': 7.5,
                    'description': f'Operating system {os_name} {os_version} is outdated',
                    'recommendation': 'Update to latest version and apply security patches',
                    'confidence': 0.8
                })
            
        except Exception as e:
            self.logger.error(f"OS analysis error: {e}")
        
        return vulnerabilities
    
    async def _analyze_ports(self, ports: List[int], features: Dict) -> List[Dict]:
        """Analyze open ports for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for dangerous open ports
            dangerous_ports = {
                21: 'FTP - Potential anonymous access',
                23: 'Telnet - Unencrypted remote access',
                135: 'RPC - Remote procedure calls',
                139: 'NetBIOS - File sharing vulnerabilities',
                445: 'SMB - File sharing vulnerabilities',
                1433: 'MSSQL - Database exposure',
                3389: 'RDP - Remote desktop vulnerabilities',
                5900: 'VNC - Remote desktop vulnerabilities'
            }
            
            for port in ports:
                if port in dangerous_ports:
                    vulnerabilities.append({
                        'type': 'dangerous_port',
                        'port': port,
                        'severity': 'Medium',
                        'severity_score': 6.0,
                        'description': dangerous_ports[port],
                        'recommendation': f'Consider closing port {port} or implementing proper security',
                        'confidence': 0.6
                    })
            
            # Check port density (too many open ports)
            if len(ports) > 20:
                vulnerabilities.append({
                    'type': 'excessive_open_ports',
                    'port_count': len(ports),
                    'severity': 'Low',
                    'severity_score': 4.0,
                    'description': f'Large number of open ports ({len(ports)}) detected',
                    'recommendation': 'Review and close unnecessary ports',
                    'confidence': 0.5
                })
            
        except Exception as e:
            self.logger.error(f"Port analysis error: {e}")
        
        return vulnerabilities
    
    async def _enhance_vulnerabilities(self, vulnerabilities: List[Dict], features: Dict) -> List[Dict]:
        """Enhance vulnerabilities with AI predictions"""
        enhanced = []
        
        try:
            for vuln in vulnerabilities:
                # Predict exploitability
                exploitability = await self._predict_exploitability(vuln, features)
                vuln['exploitability'] = exploitability
                
                # Predict severity if not set
                if 'severity_score' not in vuln:
                    severity = await self._predict_severity(vuln, features)
                    vuln['severity_score'] = severity
                    vuln['severity'] = self._score_to_severity(severity)
                
                # Add AI confidence
                if 'confidence' not in vuln:
                    vuln['confidence'] = 0.5  # Default confidence
                
                # Add CVE information if available
                cve_info = await self._find_cve_info(vuln)
                if cve_info:
                    vuln['cve'] = cve_info
                
                # Add exploit availability prediction
                exploit_available = await self._predict_exploit_availability(vuln)
                vuln['exploit_available'] = exploit_available
                
                enhanced.append(vuln)
            
        except Exception as e:
            self.logger.error(f"Vulnerability enhancement error: {e}")
            return vulnerabilities
        
        return enhanced
    
    async def _extract_features(self, scan_data: Dict) -> Dict:
        """Extract features from scan data for ML analysis"""
        features = {
            'service_count': len(scan_data.get('services', [])),
            'port_count': len(scan_data.get('ports', [])),
            'has_web_service': any(s.get('name', '').lower() in ['http', 'https'] 
                                 for s in scan_data.get('services', [])),
            'has_ssh': any(s.get('port') == 22 for s in scan_data.get('services', [])),
            'has_ftp': any(s.get('port') == 21 for s in scan_data.get('services', [])),
            'has_database': any(s.get('port') in [1433, 3306, 5432] 
                              for s in scan_data.get('services', [])),
            'os_detected': bool(scan_data.get('os_info', {})),
            'high_ports': sum(1 for p in scan_data.get('ports', []) if p > 1024),
            'low_ports': sum(1 for p in scan_data.get('ports', []) if p <= 1024)
        }
        
        return features
    
    async def _predict_severity(self, vulnerability: Dict, features: Dict) -> float:
        """Predict vulnerability severity using ML"""
        try:
            if self.severity_classifier:
                # Prepare features for prediction
                feature_vector = self._prepare_feature_vector(vulnerability, features)
                severity = self.severity_classifier.predict([feature_vector])[0]
                return float(severity)
        except Exception as e:
            self.logger.error(f"Severity prediction error: {e}")
        
        return 5.0  # Default medium severity
    
    async def _predict_exploitability(self, vulnerability: Dict, features: Dict) -> float:
        """Predict vulnerability exploitability"""
        try:
            if self.exploitability_predictor:
                feature_vector = self._prepare_feature_vector(vulnerability, features)
                exploitability = self.exploitability_predictor.predict([feature_vector])[0]
                return float(exploitability)
        except Exception as e:
            self.logger.error(f"Exploitability prediction error: {e}")
        
        return 0.5  # Default medium exploitability
    
    async def _predict_exploit_availability(self, vulnerability: Dict) -> bool:
        """Predict if exploits are available for this vulnerability"""
        try:
            # Check type of vulnerability
            vuln_type = vulnerability.get('type', '')
            
            # High availability for common vulnerabilities
            if vuln_type in ['default_credentials', 'unencrypted_protocol']:
                return True
            
            # Check CVE information
            if 'cve' in vulnerability:
                cve_id = vulnerability['cve'].get('id', '')
                if cve_id:
                    # Simplified check - in practice, this would query exploit databases
                    return vulnerability.get('severity_score', 0) > 7.0
            
            return False
            
        except Exception as e:
            self.logger.error(f"Exploit availability prediction error: {e}")
            return False
    
    def _prepare_feature_vector(self, vulnerability: Dict, features: Dict) -> List[float]:
        """Prepare feature vector for ML prediction"""
        # This is a simplified feature vector - in practice, this would be more sophisticated
        vector = [
            features.get('service_count', 0),
            features.get('port_count', 0),
            int(features.get('has_web_service', False)),
            int(features.get('has_ssh', False)),
            int(features.get('has_database', False)),
            vulnerability.get('port', 0) / 65535,  # Normalized port
            int(vulnerability.get('type') == 'default_credentials'),
            int(vulnerability.get('type') == 'unencrypted_protocol'),
        ]
        
        return vector
    
    def _score_to_severity(self, score: float) -> str:
        """Convert numerical score to severity level"""
        if score >= 9.0:
            return "Critical"
        elif score >= 7.0:
            return "High"
        elif score >= 4.0:
            return "Medium"
        else:
            return "Low"
    
    async def _load_or_create_models(self):
        """Load existing models or create new ones"""
        try:
            # Try to load existing models
            severity_model_path = os.path.join(self.models_path, 'severity_classifier.pkl')
            exploitability_model_path = os.path.join(self.models_path, 'exploitability_predictor.pkl')
            
            if os.path.exists(severity_model_path):
                with open(severity_model_path, 'rb') as f:
                    self.severity_classifier = pickle.load(f)
                self.logger.info("ðŸ“Š Loaded pre-trained severity classifier")
            else:
                await self._create_severity_classifier()
            
            if os.path.exists(exploitability_model_path):
                with open(exploitability_model_path, 'rb') as f:
                    self.exploitability_predictor = pickle.load(f)
                self.logger.info("ðŸ“Š Loaded pre-trained exploitability predictor")
            else:
                await self._create_exploitability_predictor()
            
        except Exception as e:
            self.logger.error(f"Model loading error: {e}")
            await self._create_default_models()
    
    async def _create_severity_classifier(self):
        """Create and train severity classifier"""
        try:
            # Create a simple random forest classifier with dummy data
            # In practice, this would be trained on real vulnerability data
            self.severity_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
            
            # Generate dummy training data
            X_dummy = np.random.rand(1000, 8)  # 8 features
            y_dummy = np.random.uniform(0, 10, 1000)  # Severity scores 0-10
            
            self.severity_classifier.fit(X_dummy, y_dummy)
            
            # Save model
            model_path = os.path.join(self.models_path, 'severity_classifier.pkl')
            with open(model_path, 'wb') as f:
                pickle.dump(self.severity_classifier, f)
            
            self.logger.info("ðŸ“Š Created new severity classifier")
            
        except Exception as e:
            self.logger.error(f"Severity classifier creation error: {e}")
    
    async def _create_exploitability_predictor(self):
        """Create and train exploitability predictor"""
        try:
            self.exploitability_predictor = GradientBoostingClassifier(n_estimators=100, random_state=42)
            
            # Generate dummy training data
            X_dummy = np.random.rand(1000, 8)
            y_dummy = np.random.uniform(0, 1, 1000)  # Exploitability 0-1
            
            self.exploitability_predictor.fit(X_dummy, y_dummy)
            
            # Save model
            model_path = os.path.join(self.models_path, 'exploitability_predictor.pkl')
            with open(model_path, 'wb') as f:
                pickle.dump(self.exploitability_predictor, f)
            
            self.logger.info("ðŸ“Š Created new exploitability predictor")
            
        except Exception as e:
            self.logger.error(f"Exploitability predictor creation error: {e}")
    
    async def _create_default_models(self):
        """Create basic default models if loading fails"""
        self.severity_classifier = RandomForestClassifier(n_estimators=10, random_state=42)
        self.exploitability_predictor = GradientBoostingClassifier(n_estimators=10, random_state=42)
        
        # Fit with minimal dummy data
        X_dummy = np.random.rand(10, 8)
        y_dummy = np.random.rand(10)
        
        self.severity_classifier.fit(X_dummy, y_dummy * 10)
        self.exploitability_predictor.fit(X_dummy, y_dummy)
    
    async def _load_vulnerability_database(self):
        """Load vulnerability database"""
        # In practice, this would load from a comprehensive vulnerability database
        self.vuln_database = {
            'apache': {
                '2.4.0': ['CVE-2021-44228', 'CVE-2021-45046'],
                '2.2.0': ['CVE-2017-15715', 'CVE-2017-15710']
            },
            'nginx': {
                '1.10.0': ['CVE-2017-7529'],
                '1.8.0': ['CVE-2016-0742', 'CVE-2016-0746']
            },
            'ssh': {
                '7.4': ['CVE-2018-15473'],
                '6.6': ['CVE-2016-0777', 'CVE-2016-0778']
            }
        }
    
    async def _load_cve_patterns(self):
        """Load CVE patterns for matching"""
        # Simplified CVE database
        self.cve_patterns = {
            'CVE-2021-44228': {
                'description': 'Log4j Remote Code Execution',
                'cvss_score': 10.0,
                'severity': 'Critical'
            },
            'CVE-2017-15715': {
                'description': 'Apache HTTP Server Expression injection',
                'cvss_score': 8.1,
                'severity': 'High'
            }
        }
    
    async def _check_known_vulnerabilities(self, service: str, version: str) -> List[Dict]:
        """Check for known vulnerabilities in service/version"""
        vulnerabilities = []
        
        try:
            if service in self.vuln_database:
                service_vulns = self.vuln_database[service]
                if version in service_vulns:
                    for cve_id in service_vulns[version]:
                        cve_info = self.cve_patterns.get(cve_id, {})
                        vulnerabilities.append({
                            'type': 'known_vulnerability',
                            'service': service,
                            'version': version,
                            'cve_id': cve_id,
                            'severity': cve_info.get('severity', 'Medium'),
                            'severity_score': cve_info.get('cvss_score', 5.0),
                            'description': cve_info.get('description', f'Known vulnerability {cve_id}'),
                            'recommendation': 'Update to latest version',
                            'confidence': 0.9
                        })
        except Exception as e:
            self.logger.error(f"Known vulnerability check error: {e}")
        
        return vulnerabilities
    
    async def _check_os_vulnerabilities(self, os_name: str, version: str) -> List[Dict]:
        """Check for known OS vulnerabilities"""
        # Simplified OS vulnerability checking
        vulnerabilities = []
        
        if 'windows' in os_name.lower():
            if 'xp' in version.lower() or '2003' in version:
                vulnerabilities.append({
                    'type': 'unsupported_os',
                    'os': os_name,
                    'version': version,
                    'severity': 'Critical',
                    'severity_score': 9.5,
                    'description': 'Unsupported operating system',
                    'recommendation': 'Upgrade to supported OS version',
                    'confidence': 0.95
                })
        
        return vulnerabilities
    
    async def _has_default_credentials(self, service: Dict) -> bool:
        """Check if service likely has default credentials"""
        default_credential_services = ['telnet', 'ssh', 'ftp', 'mysql', 'mssql', 'postgresql']
        service_name = service.get('name', '').lower()
        return service_name in default_credential_services
    
    async def _is_unencrypted_protocol(self, service: Dict) -> bool:
        """Check if service uses unencrypted protocol"""
        unencrypted_services = ['telnet', 'ftp', 'http', 'smtp', 'pop3', 'imap']
        service_name = service.get('name', '').lower()
        return service_name in unencrypted_services
    
    async def _is_outdated_os(self, os_info: Dict) -> bool:
        """Check if OS is outdated"""
        os_name = os_info.get('name', '').lower()
        version = os_info.get('version', '').lower()
        
        # Simplified outdated OS detection
        if 'windows' in os_name:
            return any(old_ver in version for old_ver in ['xp', '2003', '2008', 'vista'])
        elif 'ubuntu' in os_name:
            return any(old_ver in version for old_ver in ['12.04', '14.04', '16.04'])
        
        return False
    
    async def _find_cve_info(self, vulnerability: Dict) -> Optional[Dict]:
        """Find CVE information for vulnerability"""
        cve_id = vulnerability.get('cve_id')
        if cve_id and cve_id in self.cve_patterns:
            return {
                'id': cve_id,
                **self.cve_patterns[cve_id]
            }
        return None
    
    async def _predict_service_vulnerabilities(self, service: Dict, features: Dict) -> List[Dict]:
        """Use AI to predict service-specific vulnerabilities"""
        # This would use more sophisticated ML models in practice
        vulnerabilities = []
        
        service_name = service.get('name', '').lower()
        port = service.get('port', 0)
        
        # Simple rule-based predictions (would be ML-based in reality)
        if service_name == 'http' and port == 80:
            vulnerabilities.append({
                'type': 'potential_web_vuln',
                'service': service_name,
                'port': port,
                'severity': 'Medium',
                'severity_score': 6.0,
                'description': 'Web service detected - potential for web vulnerabilities',
                'recommendation': 'Perform web application security testing',
                'confidence': 0.6
            })
        
        return vulnerabilities
    
    async def get_confidence_score(self, scan_data: Dict) -> float:
        """Get AI confidence score for scan results"""
        try:
            # Calculate confidence based on data completeness and model certainty
            data_completeness = self._calculate_data_completeness(scan_data)
            model_certainty = 0.8  # Placeholder - would be calculated from model predictions
            
            confidence = (data_completeness + model_certainty) / 2
            return min(confidence, 1.0)
            
        except Exception as e:
            self.logger.error(f"Confidence calculation error: {e}")
            return 0.5
    
    def _calculate_data_completeness(self, scan_data: Dict) -> float:
        """Calculate how complete the scan data is"""
        completeness_factors = {
            'services': 0.3,
            'ports': 0.2,
            'os_info': 0.3,
            'banners': 0.1,
            'traceroute': 0.1
        }
        
        score = 0.0
        for factor, weight in completeness_factors.items():
            if factor in scan_data and scan_data[factor]:
                score += weight
        
        return score
    
    def is_ready(self) -> bool:
        """Check if analyzer is ready"""
        return self.is_initialized and self.severity_classifier is not None
